## MySQL

### 隔离级别
+ READ UNCOMMITED(未提交读)
    - 事务中的修改，即使没有提交也可以被其他事务读取
    - 也称为脏读
    - 性能上也没有优势
+ READ COMMITED(提交读)
    - 大多数数据库系统默认级别，MySQL不是
    - 只能读取已提交数据
+ REPEATEABLE READ(可重复度)
    - 保证在同一个事物中多次读取同样的数据保持一致
    - MySQL默认级别
+ SERIALIZABLE(串行化)
    - 最高的隔离级别，强制事物串行


### MVCC (多版本并发控制)
+ 行级锁的变种，实现了非阻塞读，写操作只锁定必要的行
+ **实现**：是通过保存数据在某个时间点的快照来实现
+ **InnoDB**: 通过在每行记录后面保存两个隐藏的列来实现，分别保存行的创建系统版本号和过期版本号，每开始一个事务版本号都会递增，
+ MVCC只在READ_COMMITED和REPEATABLE下工作


### InnoDB 
+ InnoDB是MySQL默认事务型引擎
+ InnoDB采用MVCC来支持高并发
+ InnoDB是基于**聚簇索引**建立的
    - 聚簇索引对主键查询有很高的性能
    - 它的二级索引（非主键索引）中必须包含主键列，因此主键列很大的话，其他所有索引都会很大。因此**表上索引很多的话，主键应尽量小**。
+ InnoDB存储格式平台独立

### MyISAM
+ MyISAM对整张表加锁，读取时加共享锁，写入时加排他锁
+ MyISAM也支持全文索引
+ **MyISAM压缩表**
    - 不会变动的数据，适合使用MyISAM压缩表



------------------

### 优化数据类型的几个简单原则
+ 更小的通常更好
+ 简单
    - 例如整形比字符比较效率更高，应该用内建类型而不是字符类型存储日期，应该用整形存储IP
+ 尽量避免NULL
    - NULL会使得索引、索引统计和值比较都更复杂
    - 可为NULL的列会使用更多存储空间，MySQL中需要做特殊处理
    - 可为NULL的列被索引时，每个索引记录需要一个额外的字节
    - DateTime和Timestamp可以存储相同类型的数据，但Timestamp只占DateTime一半存储空间，并且会根据市区变化。



-------------------

### 索引

#### 索引类型
+ B-Tree索引
    - InnoDB使用B+Tree



#### B-Tree和B+Tree的区别
+ B-Tree每个节点都存储key和data, 叶子节点不包含key
+ B+Tree所有叶子节点包含了所有key和data， 非叶子节点只包含key，叶子节点是一个链表